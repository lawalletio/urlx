import { Debugger } from 'debug';

import type { NDKEvent, NDKFilter, NostrEvent } from '@nostr-dev-kit/ndk';

import { Kind, lnOutboundTx, revertTx } from '@lib/events';
import {
  hashPaymentRequest,
  logger,
  nowInSeconds,
  requiredEnvVar,
} from '@lib/utils';

import redis from '@services/redis';
import { decode } from 'bolt11';
import { Context } from '@type/request';
import { Outbox } from '@services/outbox';
import { getReadNDK } from '@services/ndk';
import { nip04 } from 'nostr-tools';

import * as crypto from 'node:crypto';
import { settleInvoice } from '@services/lnd';
// @ts-ignore
globalThis.crypto = crypto;

const log: Debugger = logger.extend('nostr:internalTransaction');

const warn: Debugger = log.extend('warn');
const error: Debugger = log.extend('error');
const debug: Debugger = log.extend('debug');

const invoiceAmountRegex: RegExp = /^\D+(?<amount>\d+)(?<multiplier>[mnpu]?)1/i;
const BITCOIN_TOKEN_NAME = 'BTC';
const ACCEPTED_BASE_FEE = Number(requiredEnvVar('ACCEPTED_BASE_FEE'));
const ACCEPTED_FEE_PERCENT = Number(requiredEnvVar('ACCEPTED_FEE_PERCENT'));

const filter: NDKFilter = {
  kinds: [Kind.REGULAR.valueOf()],
  '#p': [requiredEnvVar('NOSTR_PUBLIC_KEY')],
  '#t': ['internal-transaction-ok'],
  since: nowInSeconds() - 86000,
};

/**
 * Extract invoice amount in millisats from invoice
 */
function extractAmount(invoice: string): bigint | null {
  const matches = invoice.match(invoiceAmountRegex);
  if (matches?.groups) {
    const multipliers: Record<string, number> = {
      p: 1e-1, // picobitcoin
      n: 1e2, // nanobitcoin
      u: 1e5, // microbitcoin
      m: 1e8, // millibitcoin
      '': 1e11, // bitcoin (default)
    };

    try {
      return BigInt(
        parseInt(matches.groups.amount) *
          multipliers[matches.groups.multiplier.toLowerCase()],
      );
    } catch {
      debug('Unparsable invoice amount');
    }
  }
  return null;
}

/**
 * Extract value of first "p" tag, or null if none found
 */
function extractFirstP(event: NostrEvent): string | null {
  try {
    return event.tags.filter((t) => 'p' === t[0])[0][1];
  } catch {
    /* ... */
  }
  return null;
}

/**
 * Extract value of first "e" tag, or null if none found
 */
function extractFirstE(event: NostrEvent): string | null {
  try {
    return event.tags.filter((t) => 'e' === t[0])[0][1];
  } catch {
    /* ... */
  }
  return null;
}

/**
 * Extract value of first "bolt11" tag, or null if none found
 */
function extractBolt11(event: NDKEvent): string | null {
  const bolt11 = event.tags.find((t) => 'bolt11' === t[0]);
  if (undefined !== bolt11) {
    return bolt11[1];
  }
  return null;
}

/**
 * Mark the given event id as handled in Redis
 */
async function markHandled(eventId: string) {
  redis.hSet(eventId, 'handled', 'true');
}

/**
 * Mark the given event as paid, publishing the outbound event
 */
async function markPaid(
  target: string,
  startEvent: NDKEvent,
  prHash: string,
  preimage: string,
  ctx: Context,
) {
  await redis.hSet(prHash, 'paid', 'true');
  log('Paid invoice for: %O', startEvent.id);
  const outboundEvent = lnOutboundTx(startEvent);
  outboundEvent.tags.push([
    'preimage',
    await nip04.encrypt(requiredEnvVar('NOSTR_PRIVATE_KEY'), target, preimage),
  ]);
  ctx.outbox.publish(outboundEvent);
}

/**
 * Publish a revert of the given event
 */
function doRevertTx(outbox: Outbox, event: NDKEvent): void {
  outbox.publish(revertTx(event));
}

/**
 * Return the internal-transaction-ok handler
 */
const getHandler = (ctx: Context): ((event: NostrEvent) => void) => {
  /**
   * Handle internal-transaction-ok
   *
   * If the internal transaction ok is one not generated by us and not
   * previously handled, get invoice and try to pay it. Publish an
   * outbound transaction on success or a revert transaction on error.
   */
  return async (event: NostrEvent) => {
    if (event.id === undefined) {
      throw new Error('Received event without id from relay');
    }

    const eventId: string = event.id;

    if ((await redis.hGet(eventId, 'handled')) !== null) {
      debug('Already handled event %s', eventId);
      return;
    }

    const target = extractFirstP(event);
    const startEventId = extractFirstE(event);

    if (null === target) {
      warn('No target found');
    }
    if (null === startEventId) {
      warn('No starting event found');
    }
    if (null === target || null === startEventId) {
      return;
    }

    // originated by me
    if (requiredEnvVar('NOSTR_PUBLIC_KEY') === target) {
      return;
    }

    const startEvent = await getReadNDK().fetchEvent(startEventId);

    debug('start event: %O', startEvent);

    if (startEvent === null) {
      warn('Did not find internalTx start for ok');
      await markHandled(eventId);
      return;
    }

    const bolt11 = extractBolt11(startEvent);

    if (null === bolt11) {
      warn('Received internal tx without invoice');
      doRevertTx(ctx.outbox, startEvent);
      await markHandled(eventId);
      return;
    }

    const content = JSON.parse(startEvent.content, (k, v) =>
      isNaN(v) ? v : BigInt(v),
    );

    const amount = extractAmount(bolt11);
    if (content.tokens[BITCOIN_TOKEN_NAME] !== amount) {
      warn('Content amount and invoice amount are different');
      doRevertTx(ctx.outbox, startEvent);
      await markHandled(eventId);
      return;
    }

    const prHash = hashPaymentRequest(bolt11);
    const decodedInvoice = decode(bolt11);
    const paymentHash = decodedInvoice.tagsObject.payment_hash!;
    debug('Payment hash: %s', paymentHash);
    debug('prHash: %s', prHash);
    if (1 !== (await redis.incr(`p:${prHash}`))) {
      await redis.decr(`p:${prHash}`);
      warn('Already paying invoice for %s', eventId);
      ctx.lnd
        .trackPayment(paymentHash)
        .then(async (payment: Payment) => {
          if (
            paymentHash !==
            crypto
              .createHash('sha256')
              .update(Buffer.from(payment.payment_preimage, 'hex'))
              .digest('hex')
          ) {
            error('INVALID PREIMAGE ON "SUCCEEDED" PAYMENT %O', payment);
          }
          const preimage = payment.payment_preimage;
          await markPaid(target, startEvent, prHash, preimage, ctx);
        })
        .catch((err) => {
          warn('Failed Tracking payment, reverting transaction: %O', err);
          doRevertTx(ctx.outbox, startEvent);
        })
        .finally(async () => {
          await redis.decr(`p:${prHash}`);
          await markHandled(eventId);
        });
      return;
    }
    const alreadyPaid =
      'true' === ((await redis.hGet(prHash, 'paid')) ?? 'false');
    if (alreadyPaid) {
      warn('Trying to pay same invoice twice');
      doRevertTx(ctx.outbox, startEvent);
      await redis.decr(`p:${prHash}`);
      await markHandled(eventId);
      return;
    }
    let invoice: Invoice | undefined = undefined;
    try {
      invoice = await ctx.lnd.getInvoice(paymentHash);
      if (
        'SETTLED' === invoice.state &&
        requiredEnvVar('NODE_PUBKEY') !== decodedInvoice.payeeNodeKey
      ) {
        log('Already paid invoice for %O, publishing event', startEvent.id);
        const outboundEvent = lnOutboundTx(startEvent);
        outboundEvent.tags.push([
          'preimage',
          await nip04.encrypt(
            requiredEnvVar('NOSTR_PRIVATE_KEY'),
            target,
            invoice.r_preimage.toString('hex'),
          ),
        ]);
        await ctx.outbox.publish(outboundEvent);
        await redis.decr(`p:${prHash}`);
        await markHandled(eventId);
        return;
      }
    } catch (err: unknown) {
      log('Error getting invoice: %O', err);
    }
    if (
      invoice &&
      requiredEnvVar('NODE_PUBKEY') === decodedInvoice.payeeNodeKey
    ) {
      const preimage = invoice.r_preimage.toString('hex');
      ctx.lnd
        .cancelInvoice(paymentHash!)
        .then(async () => {
          await markPaid(target, startEvent, prHash, preimage, ctx);
          await settleInvoice(bolt11, amount!, ctx.outbox);
        })
        .catch((err) => {
          warn('Failed paying invoice, reverting transaction: %O', err);
          doRevertTx(ctx.outbox, startEvent);
        })
        .finally(async () => {
          await redis.decr(`p:${prHash}`);
          await markHandled(eventId);
        });
      return;
    }
    const feeLimit = Math.max(
      ACCEPTED_BASE_FEE,
      Number(decodedInvoice.millisatoshis) * ACCEPTED_FEE_PERCENT,
    );

    ctx.lnd
      .payInvoice(bolt11, feeLimit)
      .then(async (payment: Payment) => {
        if (
          paymentHash !==
          crypto
            .createHash('sha256')
            .update(Buffer.from(payment.payment_preimage, 'hex'))
            .digest('hex')
        ) {
          error('INVALID PREIMAGE ON "SUCCEEDED" PAYMENT %O', payment);
        }
        const preimage = payment.payment_preimage;
        await markPaid(target, startEvent, prHash, preimage, ctx);
      })
      .catch((err) => {
        warn('Failed paying invoice, reverting transaction: %O', err);
        doRevertTx(ctx.outbox, startEvent);
      })
      .finally(async () => {
        await redis.decr(`p:${prHash}`);
        await markHandled(eventId);
      });
  };
};

export { filter, getHandler };
